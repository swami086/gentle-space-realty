/**
 * Upload Service - File Upload Management
 * 
 * MIGRATION STATUS: ‚úÖ Updated for Firebase/GCP integration
 * - File uploads: Now handled via Express API endpoints
 * - File storage: Uses backend storage solutions (Firebase Storage/GCP)
 * - File metadata: Managed via Express API in property/media endpoints
 * - File cleanup: Handled by backend services
 */

import { v4 as uuidv4 } from 'uuid';
import { ApiService } from '@/services/apiService';

export interface UploadResult {
  url: string;
  path: string;
  filename: string;
  size: number;
  mimeType: string;
}

export interface VideoUploadResult extends UploadResult {
  duration?: number;
  thumbnailUrl?: string;
}

export interface PropertyMediaUpload {
  file: File;
  type: 'image' | 'video';
}

export class UploadService {
  // File size limits
  private static readonly MAX_IMAGE_SIZE = 10 * 1024 * 1024; // 10MB
  private static readonly MAX_VIDEO_SIZE = 200 * 1024 * 1024; // 200MB

  // Supported MIME types
  private static readonly SUPPORTED_IMAGE_TYPES = [
    'image/jpeg',
    'image/jpg', 
    'image/png',
    'image/webp',
    'image/gif'
  ];

  private static readonly SUPPORTED_VIDEO_TYPES = [
    'video/mp4',
    'video/mpeg',
    'video/quicktime',
    'video/webm'
  ];

  /**
   * Upload a single file via API endpoint
   */
  static async uploadFile(file: File, folder: string = 'uploads'): Promise<UploadResult> {
    console.log(`üîÑ UploadService: Uploading file ${file.name} to ${folder}`);

    // Validate file
    this.validateFile(file);

    try {
      // Upload via API service
      const result = await ApiService.upload<UploadResult>('/upload/single', file, {
        folder: folder,
        generateUniqueName: true
      });

      console.log(`‚úÖ File uploaded successfully: ${result.filename}`);
      return result;
    } catch (error) {
      console.error('‚ùå File upload failed:', error);
      throw new Error(`File upload failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Upload multiple files for property media
   */
  static async uploadPropertyMedia(uploads: PropertyMediaUpload[], propertyId?: string): Promise<UploadResult[]> {
    console.log(`üîÑ UploadService: Uploading ${uploads.length} media files`);

    const results: UploadResult[] = [];

    for (const upload of uploads) {
      try {
        // Validate file based on type
        this.validateMediaFile(upload.file, upload.type);

        const folder = propertyId ? `properties/${propertyId}/${upload.type}s` : `temp/${upload.type}s`;
        const result = await this.uploadFile(upload.file, folder);
        
        results.push(result);
      } catch (error) {
        console.error(`‚ùå Failed to upload ${upload.file.name}:`, error);
        // Continue with other uploads, but log the error
        throw error; // Re-throw to stop the batch upload
      }
    }

    console.log(`‚úÖ Uploaded ${results.length} media files successfully`);
    return results;
  }

  /**
   * Upload property images specifically
   */
  static async uploadPropertyImages(files: File[], propertyId?: string): Promise<UploadResult[]> {
    const uploads: PropertyMediaUpload[] = files.map(file => ({
      file,
      type: 'image' as const
    }));

    return this.uploadPropertyMedia(uploads, propertyId);
  }

  /**
   * Upload property videos specifically
   */
  static async uploadPropertyVideos(files: File[], propertyId?: string): Promise<VideoUploadResult[]> {
    const uploads: PropertyMediaUpload[] = files.map(file => ({
      file,
      type: 'video' as const
    }));

    const results = await this.uploadPropertyMedia(uploads, propertyId);
    
    // Convert to VideoUploadResult (backend may provide additional video metadata)
    return results.map(result => ({
      ...result,
      duration: undefined, // Would be provided by backend video processing
      thumbnailUrl: undefined // Would be generated by backend
    }));
  }

  /**
   * Delete uploaded file via API
   */
  static async deleteFile(path: string): Promise<boolean> {
    console.log(`üóëÔ∏è UploadService: Deleting file ${path}`);

    try {
      await ApiService.delete(`/upload/file`, { path });
      console.log(`‚úÖ File deleted successfully: ${path}`);
      return true;
    } catch (error) {
      console.error(`‚ùå Failed to delete file ${path}:`, error);
      return false;
    }
  }

  /**
   * Get file URL (for accessing uploaded files)
   */
  static async getFileUrl(path: string): Promise<string> {
    try {
      const result = await ApiService.get<{ url: string }>(`/upload/url`, { path });
      return result.url;
    } catch (error) {
      console.error(`‚ùå Failed to get file URL for ${path}:`, error);
      throw error;
    }
  }

  /**
   * Validate file size and type
   */
  private static validateFile(file: File): void {
    if (!file) {
      throw new Error('No file provided');
    }

    // Check if it's an image or video
    const isImage = this.SUPPORTED_IMAGE_TYPES.includes(file.type);
    const isVideo = this.SUPPORTED_VIDEO_TYPES.includes(file.type);

    if (!isImage && !isVideo) {
      throw new Error(`Unsupported file type: ${file.type}`);
    }

    // Check file size
    if (isImage && file.size > this.MAX_IMAGE_SIZE) {
      throw new Error(`Image file size exceeds ${this.MAX_IMAGE_SIZE / 1024 / 1024}MB limit`);
    }

    if (isVideo && file.size > this.MAX_VIDEO_SIZE) {
      throw new Error(`Video file size exceeds ${this.MAX_VIDEO_SIZE / 1024 / 1024}MB limit`);
    }
  }

  /**
   * Validate media file based on specific type
   */
  private static validateMediaFile(file: File, expectedType: 'image' | 'video'): void {
    this.validateFile(file); // Basic validation first

    if (expectedType === 'image' && !this.SUPPORTED_IMAGE_TYPES.includes(file.type)) {
      throw new Error(`File ${file.name} is not a supported image format`);
    }

    if (expectedType === 'video' && !this.SUPPORTED_VIDEO_TYPES.includes(file.type)) {
      throw new Error(`File ${file.name} is not a supported video format`);
    }
  }

  /**
   * Generate unique filename
   */
  static generateUniqueFilename(originalName: string): string {
    const extension = originalName.split('.').pop();
    const uniqueId = uuidv4();
    const timestamp = Date.now();
    return `${timestamp}_${uniqueId}.${extension}`;
  }

  /**
   * Get file type from MIME type
   */
  static getFileType(mimeType: string): 'image' | 'video' | 'unknown' {
    if (this.SUPPORTED_IMAGE_TYPES.includes(mimeType)) {
      return 'image';
    }
    if (this.SUPPORTED_VIDEO_TYPES.includes(mimeType)) {
      return 'video';
    }
    return 'unknown';
  }

  /**
   * Format file size for display
   */
  static formatFileSize(bytes: number): string {
    if (bytes === 0) return '0 Bytes';

    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  /**
   * Check if file type is supported
   */
  static isFileTypeSupported(mimeType: string): boolean {
    return [...this.SUPPORTED_IMAGE_TYPES, ...this.SUPPORTED_VIDEO_TYPES].includes(mimeType);
  }

  /**
   * Get maximum file size for type
   */
  static getMaxFileSize(type: 'image' | 'video'): number {
    return type === 'image' ? this.MAX_IMAGE_SIZE : this.MAX_VIDEO_SIZE;
  }
}